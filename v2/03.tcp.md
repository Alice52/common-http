![avatar](/static/image/common/http/network-layer-tcpip.png)

## TCP

![avatar](/static/image/common/http/tcp-overview.png)

### 简介

1. Tcp{Transmission Control Protocol} 是**面向链接**的**基于字节流**的**可靠**传输控制协议

   - 面向链接: 需要先创建链接在使用, 创建链接的三{四}次握手协议有一定的开销+四次挥手
   - 基于字节流: 意味着字节是发送数据的最小单元, **Tcp 只是一个读写数据的管道**
     - Tcp 协议哪几个字节是完整的消息体
     - 也无法感知是否有多个客户端使用同一个 Tcp 链接
   - 可靠

2. MSS{Maximum Segment Size}

   - 消息在进⼊传输层{TCP}时会被切⽚为⼀个个**数据包**
   - **TCP 传输层提交给 IP 网络层最⼤分段⼤⼩**: MSS 是 TCP ⽤来限制应⽤层最⼤的发送字节数
   - 只包含 TCP Payload: 不包含 TCP Header 和 TCP Option
   - 假设 MTU= 1500 byte, 那么 MSS = 1500- 20(IP Header) -20(TCP Header) = 1460 byte
   - 如果应⽤层有 2000 byte 发送, 那么需要两个切⽚才可以完成发送, 第⼀个 TCP 切⽚ 1460byte, 第⼆个 TCP 切⽚ 540 byte

3. MTU{Maximum Transmit Unit}

   - **数据链路层允许⽹络层最⼤⼀次传输数据的⼤⼩**, 一般 MTU 是 1500Byte
   - 假设 IP 层有 <= 1500 byte 需要发送, 只需要⼀个 IP 包就可以完成发送任务
   - 假设 IP 层有> 1500 byte 数据需要发送, 需要分⽚才能完成发送, 分⽚后的 IP Header ID 相同

   ![avatar](/static/image/common/http/tcp-mss&mtu.png)

4. Tcp 头: `TCP数据⻓度=IP总⻓度 - IP Header ⻓度 - TCP Header ⻓度`

   ![avatar](/static/image/common/http/tcp-header.png)

   - 虽然能计算出长度, 但是可能是消息的一部分, 或者是多个消息组装后的数据: 因此还是会出现沾包

### tcp 沾包

1. 粘包

   - A 发送两条信息: `李东` + `亚健康终结者`
   - tcp 三次握手后建立连接, tcp 将两条消息切分组装成数据包{mss}传输
     ![avatar](/static/image/common/http/tcp-stickybag-sender.png)
   - B 接受到后, 经过 tcp 层的消息重组后得到字节流: `李东亚健康终结者`
   - 服务器将字节流处理成 `李东亚` + `健康终结者`
     ![avatar](/static/image/common/http/tcp-stickybag-receiver.png)
   - **粘包**: `李东`作为上⼀个包的内容与下⼀个包⾥的`亚`粘在了⼀起被错误地当成了⼀个数据包解析了
     ![avatar](/static/image/common/http/tcp-stickybag-result.png)

2. 为什么会出现粘包: `字节流 + 无边界 + receiver 错误还原`

   - TCP 是基于字节流传输的, 是一个传输二进制数据的管道, 传输的数据没有任何边界
   - TCP **不是以消息报为单位**向⽬的主机发送, ⽽是以**字节流**的⽅式发送到下游
   - 这些数据可能被**切割和组装成各种数据包**, 接收端收到这些数据包后没有正确还原原来的消息, 因此出
     现粘包现象
   - nagle + 接收端的没有及时读取 TCP Recv Buffer 中的数据
   - **本质原因**: 不确定消息的边界

3. 组装切割发送的原因: 充分利用资源

   - 切割: 数据包是为了能顺利通过⽹络这根⽔管{MTU}
   - 组装: TCP 发的数据都远⼩于 MSS, 每次都单独发送浪费⽹络 io + **Nagle**

4. 解决沾包

   - 关闭 nagle 可以减少沾包
   - 但是接收应⽤没有及时读取 TCP Recv Buffer 中的数据, 还是会发⽣粘包
   - **本质原因**: 不确定消息的边界
   - 解决: **在发送消息时带上消息边界的信息**, 接收端从⽽区分出每个消息
     1. 加⼊特殊标志: `消息头-消息` 类似 http 的 chunked
     2. 加⼊消息⻓度信息: `消息-长度`, 类似 Content-Length
     3. 完整性校验字段: 防止 content 中出现特殊标识 和 完整性校验

   ![avatar](/static/image/common/http/tcp-stickybag-solution.png)

### TCP Nagle 算法

1. 简介

   - 1984 年发明的: 很早之前了
   - ⽬的: `为了避免发送⼩的数据包`, 节约网络 IO
   - 针对当时应⽤程序⼀次发送⼀字节数据的场景, 现在不会这样: 因此 nagle 优化就不大, 且**可能导致延迟发送**
   - 结论: 一般都会把其关闭

2. 数据包在以下两个情况会被发送

   - 如果包⻓度达到 MSS 或含有 Fin 包, ⽴刻发送
     - 如果下⼀包到来后两个包的总⻓度超过 MSS 的话, 就会进⾏拆分发
     - 拆分余下的继续等待下一数据包
   - 等待超时(⼀般为 200ms)则⽴即发送

   ![avatar](/static/image/common/http/tcp-stickybag-send-flow.png)

---

## UDP

![avatar](/static/image/common/http/udp-overview.png)

1. 简介

   - User Datagram Protocol: ⽤户数据包协议
   - 是⾯向**⽆连接**, **不可靠**的, **基于数据报**的传输层通信协议
   - 基于数据报: ⽆论应⽤层交给 UDP 多⻓的报⽂, UDP 都照样发送, 即⼀次发送⼀个报⽂

     1. 数据报太长会在 IP 网络层分片
     2. 不会组装和切割数据报

   - 不会出现沾包问题: **udp 每次发送的是一个完整的数据报** + 头部有长度标识{即使没有也可以根据 IP 头中长度计算出来}
     1. tcp 也可以根据 IP 头中计算出来, 但是还是会: 因为不能保证是一个完整的消息

2. UDP 不出现沾包的原因

   - UDP 头上有数据长度
   - 每次都发送的是一个完整的数据报: 没被组装或切割

3. UDP 头部: `UDP数据⻓度=IP总⻓度 - IP Header ⻓度 - Udp Header ⻓度`

   ![avatar](/static/image/common/http/udp-header.png)

4. UDP 中冗余的数据长度的原因

   - 《TCP-IP 详解》⾥说可能是因为要⽤于**计算校验和**
   - 可能是因为 UDP 底层使⽤的可以不是 IP 协议: 计算不出来
   - 从 Socket Buffer 中读取到的 UDP 数据没有 IP Header 信息{长度信息}: 在网络层会解析 IP 数据包并去掉 header 交给传输层

   ![avatar](/static/image/common/http/udp-stickybag-no.png)

---

## IP

1. IP 报头

   ![avatar](/static/image/common/http/ip-deader.png)

2. tcp/udp 数据长度

   ![avatar](/static/image/common/http/ip-length.png)

3. 分包&装包

   - IP 层 会按 MTU ⻓度把消息分成 N 个切⽚: 在包⾥的位置 offset 和同样的 IP 头信息
   - 最后会在所有 IP 数据包都到达终点后再组装: `IP头 + 顺序offfset`
   - 之后处理掉 IP 头后传输给传输层

4. IP 不会出现沾包

   - IP 分包和 TCp 不一样: 不会讲不同的消息组装成一个数据包
   - 同一数据包分割后会有相同的 IP 头信息 + 每个包都有自己的 offset

5. ip 数据包的传输过程

   ![avatar](/static/image/common/http/ip-transfer.png)
